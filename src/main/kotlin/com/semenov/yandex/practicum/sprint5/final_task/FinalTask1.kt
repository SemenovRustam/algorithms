package com.semenov.yandex.practicum.sprint5.final_task

/**
 * https://contest.yandex.ru/contest/24810/run-report/119607509/
 *  Принцип работы:
 *  Создаю макс.кучу просеиванием вниз
 *  Сортирую список
 *
 * siftDown - функция просеивания:
 * Находит левый и правый индекс, если левый индекс больше размера списка, тогда ф-ия прекращается
 *
 * Берется максимальный индекс: если правый существует - берем правый, если правого нет - берем левый.
 * Если родительский элемент меньше своих потомков - происходит смена мест этих елементов и рекурсивно вызывается
 * ф-ия siftDown
 *
 * Временная сложность:
 * Построение кучи - O(log n)
 * Сортировка - O(n log n).
 * Общая - O(n log n).
 *
 * Пространственная сложность - константная O(1), тк алгоритм не создает дополнительные структуры данных, а
 * модифицирует исходный массив
 * */

import java.util.Collections.swap

fun main() {
    val count = readln().toInt()
    val person = Array(count) {
        val (name, solvedTask, fine) = readln().split(" ")
        Person(
            name = name,
            solvedTask = solvedTask.toInt(),
            fine = fine.toInt()
        )
    }.toMutableList()

    val memberComparator = compareByDescending<Person> { it.solvedTask }
        .thenBy { it.fine }
        .thenBy { it.name }

    person.heapSort(memberComparator)

    val result = person.joinToString("\n") { it.name }
    println(result)

}

fun <T> MutableList<T>.heapSort(comparator: Comparator<T>) {
    for (i in size / 2 downTo 0) {
        siftDown(comparator, i, size)
    }

    for (i in size - 1 downTo 1) {
        swap(this, 0, i)
        siftDown(comparator, 0, i)
    }
}

fun <T> MutableList<T>.siftDown(comparator: Comparator<T>, start: Int, end: Int) {
    val left = 2 * start + 1
    val right = left + 1

    if (left >= end) return

    val largestIndex = if (right < end && comparator.compare(this[left], this[right]) < 0) right else left

    if (comparator.compare(this[start], this[largestIndex]) < 0) {
        swap(this, start, largestIndex)
        siftDown(comparator, largestIndex, end)
    }
}

data class Person(
    val name: String,
    val solvedTask: Int,
    val fine: Int
)


/**
 * A. Пирамидальная сортировка
Язык	Ограничение времени	Ограничение памяти	Ввод	Вывод
Все языки	5 секунд	256Mb	стандартный ввод или input.txt	стандартный вывод или output.txt
Swift 5.8.1	0.7 секунд	64Mb
OpenJDK Java 11	1.5 секунд	256Mb
C# (MS .NET 6.0 + ASP)	1.5 секунд	256Mb
Kotlin 1.8.0 (JRE 11)	1.5 секунд	256Mb
GNU c++17 7.3	0.7 секунд	64Mb
C# (MS .NET 5.0 + ASP)	1.5 секунд	256Mb
GNU GCC 12.2 C++20	0.7 секунд	64Mb
В данной задаче необходимо реализовать сортировку кучей. При этом кучу необходимо реализовать самостоятельно,
использовать имеющиеся в языке реализации нельзя. Сначала рекомендуется решить задачи про просеивание вниз и вверх.

Тимофей решил организовать соревнование по спортивному программированию, чтобы найти талантливых стажёров.
Задачи подобраны, участники зарегистрированы, тесты написаны. Осталось придумать,
как в конце соревнования будет определяться победитель.

Каждый участник имеет уникальный логин. Когда соревнование закончится, к нему будут привязаны два показателя:
количество решённых задач Pi и размер штрафа Fi. Штраф начисляется за неудачные попытки и время, затраченное на задачу.

Тимофей решил сортировать таблицу результатов следующим образом: при сравнении двух участников выше будет идти тот,
у которого решено больше задач. При равенстве числа решённых задач первым идёт участник с меньшим штрафом.
Если же и штрафы совпадают, то первым будет тот, у которого логин идёт раньше в алфавитном (лексикографическом) порядке.

Тимофей заказал толстовки для победителей и накануне поехал за ними в магазин. В своё отсутствие он поручил
вам реализовать алгоритм сортировки кучей (англ. Heapsort) для таблицы результатов.

Формат ввода
В первой строке задано число участников n, 1 ≤ n ≤ 100 000.
В каждой из следующих n строк задана информация про одного из участников.
i-й участник описывается тремя параметрами:

уникальным логином (строкой из маленьких латинских букв длиной не более 20)
числом решённых задач Pi
штрафом Fi
Fi и Pi — целые числа, лежащие в диапазоне от 0 до 109.
Формат вывода
Для отсортированного списка участников выведите по порядку их логины по одному в строке.

Пример 1
Ввод
5
alla 4 100
gena 6 1000
gosha 2 90
rita 2 90
timofey 4 80

Вывод
gena
timofey
alla
gosha
rita

 */