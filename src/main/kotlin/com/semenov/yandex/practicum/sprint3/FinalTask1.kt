package com.semenov.yandex.practicum.sprint3

/**
 * https://contest.yandex.ru/contest/23815/run-report/116748055/

-- ПРИНЦИП РАБОТЫ --
Алгоритм работает с помощью двух указателей.
Определяем границы поиска.
В цикле пока левая граница не пересечет правую:
- Вычисляем средний индекс.
- Проверяем какая часть массива отсортирована.
- В отсортированной части массива сдвигаем границы для поиска нужного элемента

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Алгоритм использует бинарный бинарный поиск, поэтому временная сложность алгоритма - логарифмическая О(log n)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Так как алгоритм использует только несколько вспомогательных переменных:
- указатель границ и середину массива,
то пространственная сложность не зависит от размеров входного массива т.е. = О(1)
 */

fun main() {
    readln()
    val k = readln().toInt()
    val array = readln().split(" ").map { it.toInt() }.toIntArray()

    println(brokenSearch(array, k))
}


fun brokenSearch(arr: IntArray, target: Int): Int {
    var left = 0
    var right = arr.size - 1

    while (left <= right) {
        val mid = (left + right) / 2
        if (arr[mid] == target) return mid

        if (arr[left] <= arr[mid]) {
            if (target >= arr[left] && target < arr[mid]) {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if (target > arr[mid] && target <= arr[right]) {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }

    return -1
}

/**
 *
9
5
19 21 100 101 1 4 5 7 12


Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере.
Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время.
Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные исходной отсортированной
последовательности (при этом массив все равно мог остаться отсортированным).
Тем не менее, нужно обеспечить возможность находить в нем элемент за
O(logn).
Можно предполагать, что в массиве только уникальные элементы.
От вас требуется реализовать функцию, осуществляющую поиск в сломанном массиве. Обратите внимание,
что считывать данные и выводить ответ не требуется.
Используйте заготовки кода для данной задачи, расположенные по ссылкам:

c++
Java
js
Python
C#
go
Kotlin
Swift


Формат ввода
Функция принимает массив натуральных чисел и искомое числоk. Длина массива не превосходит
10000. Элементы массива и число k не превосходят по значению 10000.

В примерах:
В первой строке записано число
n–— длина массива.
Во второй строке записано положительное число k–— искомый элемент.
Далее в строку через пробел записано n натуральных чисел – элементы массива.

Вы можете ознакомиться с инструкцией по работе с Make на платформе в разделе "Начало тема «Введение в алгоритмы»,
урок «Оптимизация ввода и вывода»

Формат вывода
Функция должна вернуть индекс элемента, равного
k
, если такой есть в массиве (нумерация с нуля). Если элемент не найден, функция должна вернуть
−
1
.
Изменять массив нельзя.
Для отсечения неэффективных решений ваша функция будет запускаться от
100000 до 1000000 раз.

Пример 1
Ввод	Вывод
9
5
19 21 100 101 1 4 5 7 12
6
Пример 2
Ввод	Вывод
2
1
5 1
1
 */