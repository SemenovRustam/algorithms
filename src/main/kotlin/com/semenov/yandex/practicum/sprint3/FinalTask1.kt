package com.semenov.yandex.practicum.sprint3

/**
https://contest.yandex.ru/contest/23815/run-report/116877348/

-- ПРИНЦИП РАБОТЫ --
Алгоритм работает с помощью двух указателей: левый - начало массива, правый - конец массива.

Определяем границы поиска.
В цикле пока левая граница не пересечет правую:
- Вычисляем средний индекс.
- Проверяем на совпадение элемента под средним индексом с искомым элементом, если элемент совпадает возвращаем значение индекса.

- Проверяем какая часть массива отсортирована:
Если элемент под средним индексом больше или равен элементу под левым индексом - тогда левая часть массива отсортирована:
Если искомый элемент находится в пределах отсортированной левой части массива, то сужаем поиск только в левой части, установив
правую границу массива как mid - 1, в противном случае ищем в правой части массива установив левую границу как mid + 1.

Если элемент под средним индексом меньше элемента под левым индексом - тогда правая часть массива отсортирована:
Если искомый элемент находится в пределах отсортированной правой части массива, то сужаем поиск до правой части,
изменив значение left как mid + 1, в противном случае ищем в левой части массива, установив правую границу поиска,
как right = mid - 1.

Если цикл завершился, а искомый элемент не найден, тогда будет возвращено -1.

-- Доказательство корректности алгоритма --
Алгоритм работает корректно, так как изначально мы проверяем, какая часть массива отсортирована.
При каждой итерации сужаем область поиска в два раза, путем проверки нахождения искомого элемента в определенной части массива.
Если элемент существует, то алгоритм гарантированно найдет его, тк проверяет все возможные позиции.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Алгоритм использует бинарный бинарный поиск, поэтому временная сложность алгоритма - логарифмическая О(log n)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Так как алгоритм использует только несколько вспомогательных переменных:
- указатель границ и середину массива,
то пространственная сложность не зависит от размеров входного массива т.е. = О(1)
 */

fun main() {
    readln()
    val k = readln().toInt()
    val array = readln().split(" ").map { it.toInt() }.toIntArray()

    println(brokenSearch(array, k))
}

fun brokenSearch(arr: IntArray, target: Int): Int {
    var left = 0
    var right = arr.lastIndex

    while (left <= right) {
        val mid = (left + right) / 2
        if (arr[mid] == target) return mid

        if (arr[left] <= arr[mid]) {
            val range = arr[left]..arr[mid]
            if (target in range) {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if (target in arr[mid]..arr[right]) {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }

    return -1
}

/**
 *
9
5
19 21 100 101 1 4 5 7 12


Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере.
Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время.
Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные исходной отсортированной
последовательности (при этом массив все равно мог остаться отсортированным).
Тем не менее, нужно обеспечить возможность находить в нем элемент за
O(logn).
Можно предполагать, что в массиве только уникальные элементы.
От вас требуется реализовать функцию, осуществляющую поиск в сломанном массиве. Обратите внимание,
что считывать данные и выводить ответ не требуется.
Используйте заготовки кода для данной задачи, расположенные по ссылкам:

c++
Java
js
Python
C#
go
Kotlin
Swift


Формат ввода
Функция принимает массив натуральных чисел и искомое числоk. Длина массива не превосходит
10000. Элементы массива и число k не превосходят по значению 10000.

В примерах:
В первой строке записано число
n–— длина массива.
Во второй строке записано положительное число k–— искомый элемент.
Далее в строку через пробел записано n натуральных чисел – элементы массива.

Вы можете ознакомиться с инструкцией по работе с Make на платформе в разделе "Начало тема «Введение в алгоритмы»,
урок «Оптимизация ввода и вывода»

Формат вывода
Функция должна вернуть индекс элемента, равного
k
, если такой есть в массиве (нумерация с нуля). Если элемент не найден, функция должна вернуть
−
1
.
Изменять массив нельзя.
Для отсечения неэффективных решений ваша функция будет запускаться от
100000 до 1000000 раз.

Пример 1
Ввод	Вывод
9
5
19 21 100 101 1 4 5 7 12
6
Пример 2
Ввод	Вывод
2
1
5 1
1
 */