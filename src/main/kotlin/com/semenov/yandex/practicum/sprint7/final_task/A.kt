package com.semenov.yandex.practicum.sprint7.final_task

/**
 * https://contest.yandex.ru/contest/25597/run-report/123570571/
 *
 * https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%9B%D0%B5%D0%B2%D0%B5%D0%BD%D1%88%D1%82%D0%B5%D0%B9%D0%BD%D0%B0
 *
 * Принцип работы:
 *
 * Матрица  dp:
 * 1) dp - двумерный массив, где в dp[i][j] хранится минимальное кол-во операций для преобразования первых символов i
 * первой s в первые j символы строки t.
 * 2) базовый случай: [i][0] для преобразовая строки s в пустую строку t  потребуется s.length операций,
 *      аналогично для преобразования строки t в пустую строку s% [0][j].
 * 3) в процессе заполнения массива проверяется символы на равенство: если равны, берется значение на i-1 и j -1, тк доп
 * операции не требуются, если же не равны, тогда берется минимум от трех операций: вставка, удаление, замена
 * 4) алгоритм заполнения данных используется по возрастанию
 * 5) искомый ответ будет лежать в правой нижней части массиве dp
 *
 *
 * levenshteinRange: функция считывает, сколько операция необходимо, чтобы строку s преобразовать к t.
 * Инициализирую матрицу dp, в котором будет храниться расстояние по Левенштейну.
 *
 * Заполняю первую строку и первый столбец.
 *
 * В внешнем цикле проходимся по всем символам строки s,
 * а во внутреннем - по всем символам строки t.
 *
 * Если символы равны - то расстояние по Левенштейну не увеличивается, те будет равным для прежних символов.
 *
 * Если символы не равны, то мы берем минимум из трех возможных операций:
 *  Удаление: dp[i - 1][j] + 1 — удаляем последний символ строки s.
 *  Вставка: dp[i][j - 1] + 1 — добавляем последний символ строки t.
 *  Замена: dp[i - 1][j - 1] + 1 — заменяем последний символ строки s на последний символ строки t.
 *
 *  Временная сложность - O(m * n), где n и м  - длины строк, которые сравниваются
 *
 *  Пространственная сложность - O(m * n), тк нам приходится хранить матрицу размером m*n
 *
 *
 * */


fun main() {
    val s = readln()
    val t = readln()

    val result = levenshteinRange(s, t)
    println(result)
}

fun levenshteinRange(s: String, t: String): Int {
    val dp = Array(s.length + 1) { IntArray(t.length + 1) }

    for (i in 0..s.length) {
        dp[i][0] = i
    }
    for (j in 0..t.length) {
        dp[0][j] = j
    }

    for (i in 1..s.length) {
        for (j in 1..t.length) {
            if (s[i - 1] == t[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1]
            } else {
                dp[i][j] = minOf(
                    dp[i - 1][j] + 1,
                    dp[i][j - 1] + 1,
                    dp[i - 1][j - 1] + 1
                )
            }
        }
    }

    return dp[s.length][t.length]
}
