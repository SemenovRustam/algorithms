package com.semenov.yandex.practicum.sprint7.final_task

/**
 * https://contest.yandex.ru/contest/25597/run-report/123893752/
 *
 * https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%9B%D0%B5%D0%B2%D0%B5%D0%BD%D1%88%D1%82%D0%B5%D0%B9%D0%BD%D0%B0
 *
 * Принцип работы:
 *
 * Матрица  dp:
 * 1) dp - двумерный массив, где в dp[i][j] хранится минимальное кол-во операций для преобразования первых символов i
 * первой s в первые j символы строки t.
 * 2) базовый случай: [i][0] для преобразовая строки s в пустую строку t  потребуется s.length операций,
 *      аналогично для преобразования строки t в пустую строку s% [0][j].
 * 3) в процессе заполнения массива проверяется символы на равенство: если равны, берется значение на i-1 и j -1, тк доп
 * операции не требуются, если же не равны, тогда берется минимум от трех операций: вставка, удаление, замена
 * 4) алгоритм заполнения данных используется по возрастанию
 * 5) искомый ответ будет лежать в правой нижней части массиве dp
 *
 *
 * levenshteinRange: функция считывает, сколько операция необходимо, чтобы строку s преобразовать к t.
 * Инициализирую матрицу dp, в котором будет храниться расстояние по Левенштейну.
 *
 * Заполняю первую строку и первый столбец.
 *
 * В внешнем цикле проходимся по всем символам строки s,
 * а во внутреннем - по всем символам строки t.
 *
 * Если символы равны - то расстояние по Левенштейну не увеличивается, те будет равным для прежних символов.
 *
 * Если символы не равны, то мы берем минимум из трех возможных операций:
 *  Удаление: dp[i - 1][j] + 1 — удаляем последний символ строки s.
 *  Вставка: dp[i][j - 1] + 1 — добавляем последний символ строки t.
 *  Замена: dp[i - 1][j - 1] + 1 — заменяем последний символ строки s на последний символ строки t.
 *
 *  Временная сложность - O(m * n), где n и м  - длины строк, которые сравниваются
 *
 *  Пространственная сложность - O(m * n), тк нам приходится хранить матрицу размером m*n
 *
 *  Для оптимизации пространственной сложности использовал не матрицу, а два массива, тк по сути для вычисления
 *  операций для преоброзования, необходима текущая и предыдущая строка.
 *  Итоговая Пространственная сложность после оптимизации - O(n),
 *
 * */


fun main() {
    val s = readln()
    val t = readln()

    val result = levenshteinRange(s, t)
    println(result)
}


fun levenshteinRange(s: String, t: String): Int {
    var current = IntArray(t.length + 1)
    var previous = IntArray(t.length + 1) { it }

    for (i in 1..s.length) {
        current[0] = i
        for (j in 1..t.length) {
            val coast = if (s[i - 1] == t[j - 1]) 0 else 1
            val deleted = previous[j] + 1
            val added = current[j - 1] + 1
            val changed = previous[j - 1] + coast
            current[j] = minOf(deleted, added, changed)
        }
//        val temp = current
//        current = previous
//        previous = temp
        current = previous.also { previous = current }
    }
    return previous.last()
}

/**
 * A. Расстояние по Левенштейну
Все языки	Python 3.11.4
Ограничение времени	0.5 секунд	2.3 секунды
Ограничение памяти	64Mb	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Расстоянием Левенштейна между двумя строками s и t называется количество атомарных изменений,
с помощью которых можно одну строку превратить в другую. Под атомарными изменениями подразумеваются:
удаление одного символа, вставка одного символа, замена одного символа на другой.

Найдите расстояние Левенштейна для предложенной пары строк.

Выведите единственное число — расстояние между строками.

Формат ввода
В первой строке дана строка s, во второй — строка t. Длины обеих строк не превосходят 1000.
Строки состоят из маленьких латинских букв.

Пример 1
Ввод
abacaba
abaabc
Вывод
2

Пример 2
Ввод
innokentiy
innnokkentia

Вывод
3

Пример 3
Ввод
r
x

Вывод
1
 */

